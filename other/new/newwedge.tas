
; 64net/2 wedge by Paul G-S, 1996
;
; reassembled by Maciej Witkowiak, 20.4.2000
; this is ACME crossassembler version
; 23.4.2000 - linux module version

; TODO:
; - use kernal tape driver space (allow burning modified kernal)
; - think about throwing open/close/chkin/chkout/chrin/chrout stuff out
;   and replacing it with more low-level listen/second/acptr/unlisten/talk/tksa/untalk
;   (hope that dos wedge of Action Replay will work then and I can't live without it :-)
; - when above will be known, make C128 version (conditional)

!to "newedge.64"
!set devnum = 1

;0xf4 - fastgetblock	(machdep.c)
;0xf5 - fastsendblock	(machdep.c)
;0xf6 - ???
;0xf7 - client_type query (clientdep.c)
;0xf8 - jsr		(comm-lpt.c)
;0xf9 - ???
;0xfd - print		(comm-lpt.c)
;0xfe - error		(comm-lpt.c)
;	0 - none
;	4 - file not found
;	xx - error code
;0xff - followed by:	(comm-lpt.c)
;	1 - poke
;	2 - peek


		* = $0801
		
		!word $080b, 2000
		!byte $9e
		!text "2061"
		!byte 0,0,0

		ldx #0
cp_lp1		lda chunk1,x
		sta $02a7,x
		inx
		cpx #chunk2-chunk1
		bne cp_lp1
		ldx #0
cp_lp2		lda chunk2,x
		sta $0340,x
		inx
		cpx #chunk3-chunk2
		bne cp_lp2
		ldx #0
cp_lp3		lda chunk3,x
		sta $fd50,x
		lda chunk3+$100,x
		sta $fd50+$100,x
		lda chunk3+$200-$50,x
		sta $fd50+$200-$50,x
		inx
		bne cp_lp3

		lda $dd0d
		lda $dd0d
		lda #7
		sta $a7
		jmp $02a7

chunk1
		!pseudopc $02a7
boot_up
		jsr rom_off
		jsr init_vectors
		ldy #$42	;'B'
		jmp do_command

check_dev	lda $ba
		cmp #devnum
		beq chkdv1
		cmp $a7
chkdv1		rts
	
new_load	pha
		jsr check_dev
		beq nload_cont
		pla
		jmp $f4a5
nload_cont	sty $b3
		pla
		ldy #$4c	; 'L'
do_command	jsr rom_off
		jsr sendname
		jmp rom_on

new_save	pha
		jsr check_dev
		beq nsave_cont
		pla
		jmp $f5ed
nsave_cont	sty $b3
		pla
		ldy #$53	; 'S'
		jmp do_command

		!realpc
chunk2
		!pseudopc $0340

new_open	jsr check_dev
    		beq nopen_cont
		jmp $f34a
nopen_cont	ldy #$4f	; 'O'
		jmp do_command

new_chrout	pha
		lda $9a
		cmp $a7
		beq nchro_cont
		pla
		jmp $f1ca
nchro_cont	jsr rom_off
		pla
	        jsr do_chrout
	        jmp rom_on

new_getin	lda $99
	        cmp $a7
	        beq ngeti_cont
	        jmp $f13e

new_chrin	jmp $f157
	        lda $99
	        cmp $a7
	        bne nchri_cont
ngeti_cont	jsr rom_off
	        jsr do_chrin
		jmp rom_on
nchri_cont	jmp $f157
	    
new_chkin	jsr rom_off
	        jsr getdevnum
	        jsr rom_on
	        cmp $a7
	        bne nchki_cont
	        jsr rom_off
	        jsr do_chkin
		jmp rom_on
nchki_cont	jmp $f20e
	    
new_chkout	txa
	        jsr rom_off
	        jsr getdevnum
	        jsr rom_on
	        cmp $a7
	        bne nchko_cont
	        jsr rom_off
	        jsr do_chkout
	        jmp rom_on
nchko_cont	jmp $f250

new_close	tax
	        pha
	        jsr rom_off
	        jsr getdevnum
	        cmp $a7
	        bne nclos_cont
	        jsr rom_off
	        jsr do_close
nclos_cont	jsr rom_on
		pla
		jmp $f291
	    
rom_off	        sei
	        lda #$35
	        sta $01
		rts
	    
rom_on		pha
	        lda #$37
	        sta $01
	        pla
	        cli
	        clc
	        rts
	    
old_chrout	pha
	        jsr rom_on
	        jsr $ffd2
	        jsr rom_off
	        pla
	        rts

		!realpc
chunk3
		!pseudopc $fd50

do_chrout	pha
		lda #$57	; 'W'
		jsr sendbyte
		pla
		jsr sendbyte
		rts

do_chrin	lda #$52	;'R'
		jsr sendbyte
		jsr getbyte
		sta $90
		jsr getbyte
		rts

do_chkin	lda #$44	;'D'
		jsr sendbyte
		lda $026d,y
		and #$1f
		jsr sendbyte
		lda $a7
		sta $99
		rts

do_chkout	lda #$41	;'A'
		jsr sendbyte
		lda $026d,y
		and #$1f
		jsr sendbyte
		lda $a7
		sta $9a
		rts

do_close	lda #$43	;'C'
		jsr sendbyte
		pla
		pha
		jmp sendbyte

getdevnum	txa
		stx $b4
		ldx #9
gdnm_loop	cmp $0259,x
		beq gdnm_cont
		dex
		bpl gdnm_loop
		ldx $b4
		sec
		rts
gdnm_cont	txa
		tay
		lda $0263,x
		ldx $b4
		clc
		rts

sendname	stx $b2
		tya
		jsr sendbyte
		lda $b7
		jsr sendbyte
		lda $b7
		beq sdnm_cont
		ldy #0
sdnm_loop	lda ($bb),y
		jsr sendbyte
		iny
		cpy $b7
		bne sdnm_loop
sdnm_cont	lda $b9
		jsr sendbyte
		jmp command_loop

getadrnum	jsr getbyte
		sta $10
getaddress	jsr getbyte
		sta $9e
		jsr getbyte
		sta $9f
		rts

fastload	jsr getaddress
		ldy #0
fl_loop		jsr getbyte
		sta ($9e),y
		iny
		jsr getbyte
		sta ($9e),y
		iny
		cpy #$fe
		bne fl_loop
		beq command_loop	; it's near - why waste byte?

fastsave	jsr getaddress
		ldy #0
fs_loop		lda ($9e),y
		jsr sendbyte
		iny
		lda ($9e),y
		jsr sendbyte
		iny
		cpy #$fe
		bne fs_loop
		beq command_loop	; it's near - why waste byte?

os_type		lda #$40
		jsr sendbyte

command_loop	jsr getbyte
		cmp #$f5
		beq fastload
		cmp #$f4
		beq fastsave
		cmp #$f7
		beq os_type
		cmp #$f6
		beq unk2
		cmp #$ff
		beq peekpoke
		cmp #$fe
		beq error
		cmp #$fd
		beq print
		cmp #$f9
		beq unk1
		cmp #$f8
		bne command_loop
		jmp do_jsr

error		jsr getbyte
		tax
		clc
		beq no_error
		sec
no_error	ldx $b2
		ldy $b3
		rts

print		jsr getbyte
		cmp #0
		beq print_end
		jsr old_chrout
		jmp print
print_end	jmp command_loop

unk1		jsr getbyte
		jsr $ffe4
		jsr sendbyte
		jmp command_loop

unk2		jsr getbyte
		jsr $f157
		jsr sendbyte
		jmp command_loop

peekpoke	lda #$ff
		jsr getbyte
		cmp #1
		beq poke
		jmp peek
poke		lda #0
		sta $aa
		jsr getadrnum
		ldx $10
		ldy #$ff
poke_loop	iny
		dex
		beq poke_end
		jsr getbyte
		pha
		lda #$34
		sta $01
		pla
		sta ($9e),y
		lda #$35
		sta $01
		jmp poke_loop
poke_end	jmp command_loop

do_jsr		ldx #0
dojsr_lp	lda codejsr,x
		sta $0334,x
		inx
		cpx #9
		bne dojsr_lp
		jsr getbyte
		sta $0338
		jsr getbyte
		sta $0339
		jsr getbyte
		pha
		jsr getbyte
		tax
		jsr getbyte
		tay
		jsr getbyte
		pla
		jsr $0334
		jmp command_loop

codejsr		jsr rom_on
		jsr command_loop
		jmp rom_off

peek		jsr getadrnum
		jsr getbyte
		ldx $10
		ldy #$ff
peek_loop	iny
		dex
		beq peek_end
		lda ($9e),y
		jsr sendbyte
		jmp peek_loop
peek_end	jmp command_loop

getbyte		lda #$10
		bit $dd0d
		beq *-3
		lda $dd01
		rts

sendbyte	pha
		lda #$ff
		sta $dd03
		pla
		sta $dd01
		lda #$10
		bit $dd0d
		beq *-3
		lda #0
		sta $dd03
		rts

init_vectors	ldx #0
iniv_loop	lda vectortab,x
		beq iniv_end
		tay
		inx
		lda vectortab,x
		sta $0300,y
		inx
		lda vectortab,x
		inx
		sta $0301,y
		jmp iniv_loop
iniv_end	rts

vectortab	!byte $1a
		!word new_open
		!byte $1c
		!word new_close
		!byte $1e
		!word new_chkin
		!byte $20
		!word new_chkout
		!byte $24
		!word new_chrin
		!byte $26
		!word new_chrout
		!byte $2a
		!word new_getin
		!byte $30
		!word new_load
		!byte $32
		!word new_save
		!byte 0

		!realpc
